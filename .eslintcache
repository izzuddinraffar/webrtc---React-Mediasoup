[{"/home/izzud/Desktop/app/webrtc_mediasoup/src/reportWebVitals.js":"1","/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/home/index.tsx":"2","/home/izzud/Desktop/app/webrtc_mediasoup/src/index.js":"3","/home/izzud/Desktop/app/webrtc_mediasoup/src/App.js":"4","/home/izzud/Desktop/app/webrtc_mediasoup/src/CONTAINER/layout.tsx":"5","/home/izzud/Desktop/app/webrtc_mediasoup/src/app.config.js":"6","/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-broadcast/subscribe.tsx":"7","/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-broadcast/index.tsx":"8","/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-conference/room.tsx":"9","/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-broadcast/publish.tsx":"10","/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-conference/index.tsx":"11"},{"size":362,"mtime":1607107118941,"results":"12","hashOfConfig":"13"},{"size":1038,"mtime":1607332813616,"results":"14","hashOfConfig":"13"},{"size":613,"mtime":1607260661652,"results":"15","hashOfConfig":"13"},{"size":975,"mtime":1607343259034,"results":"16","hashOfConfig":"13"},{"size":414,"mtime":1607269297240,"results":"17","hashOfConfig":"13"},{"size":102,"mtime":1607269821171,"results":"18","hashOfConfig":"13"},{"size":12630,"mtime":1611659416969,"results":"19","hashOfConfig":"13"},{"size":762,"mtime":1611614138023,"results":"20","hashOfConfig":"13"},{"size":36699,"mtime":1611863747919,"results":"21","hashOfConfig":"13"},{"size":11179,"mtime":1611615065563,"results":"22","hashOfConfig":"13"},{"size":494,"mtime":1611601395758,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1nd4583",{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"34"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"44","messages":"45","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"52"},"/home/izzud/Desktop/app/webrtc_mediasoup/src/reportWebVitals.js",[],"/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/home/index.tsx",[],["53","54"],"/home/izzud/Desktop/app/webrtc_mediasoup/src/index.js",[],"/home/izzud/Desktop/app/webrtc_mediasoup/src/App.js",["55","56","57"],"import React, { Suspense } from 'react';\nimport logo from './logo.svg';\nimport { Route, Switch, Redirect } from 'react-router-dom';\nimport { io as socketIOClient } from 'socket.io-client';\nimport './App.css';\n\nconst Home = React.lazy(() => import('./PAGE/home/index'));\nconst Broadcast = React.lazy(() => import('./PAGE/video-broadcast/index'));\nconst Conference = React.lazy(() => import('./PAGE/video-conference/index'));\n\nfunction App() {\n    return (\n        <div className='App'>\n            <Switch>\n                <Suspense fallback={<div>Loading...</div>}>\n                    <Route path='/' exact component={Home} />\n                    <Route\n                        path='/broadcast/:view'\n                        exact\n                        component={Broadcast}\n                    />\n                    <Route path='/conference' exact component={Conference} />\n                </Suspense>\n            </Switch>\n        </div>\n    );\n}\n\nexport default App;\n",["58","59"],"/home/izzud/Desktop/app/webrtc_mediasoup/src/CONTAINER/layout.tsx",["60","61","62"],"/home/izzud/Desktop/app/webrtc_mediasoup/src/app.config.js",[],"/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-broadcast/subscribe.tsx",["63","64","65","66","67","68"],"import React, { Suspense, lazy } from 'react';\nimport { Device } from 'mediasoup-client';\nimport { io as socketIOClient } from 'socket.io-client';\nimport { config } from '../../app.config';\nfunction Subscribe(props: any) {\n    const remoteVideo: any = React.useRef();\n    const localStream: any = React.useRef();\n    const clientId: any = React.useRef();\n    const device: any = React.useRef();\n    const consumerTransport: any = React.useRef();\n    const videoConsumer: any = React.useRef();\n    const audioConsumer: any = React.useRef();\n    const socketRef: any = React.useRef();\n\n    const [isSubscribed, setIsSubscribed] = React.useState(false);\n\n    const [isConnected, setIsConnected] = React.useState(false);\n\n    // return Promise\n    function playVideo(element: any, stream: any) {\n        if (element.srcObject) {\n            console.warn('element ALREADY playing, so ignore');\n            return;\n        }\n        element.srcObject = stream;\n        element.volume = 0;\n        remoteVideo.current = element;\n        console.log('playVideo');\n        console.log(remoteVideo);\n        return element.play();\n    }\n\n    function pauseVideo(element: any) {\n        element.pause();\n        element.srcObject = null;\n    }\n\n    function addRemoteTrack(id: any, track: any) {\n        let video: any = remoteVideo.current;\n\n        if (video.srcObject) {\n            video.srcObject.addTrack(track);\n            return;\n        }\n\n        const newStream = new MediaStream();\n        newStream.addTrack(track);\n        playVideo(video, newStream)\n            .then(() => {\n                video.volume = 1.0;\n            })\n            .catch((err: any) => {\n                console.error('media ERROR:', err);\n            });\n    }\n\n    // ============ UI button ==========\n\n    async function handleSubscribe() {\n        //if (!socketRef.current) {\n        await connectSocket().catch((err: any) => {\n            console.error(err);\n            return;\n        });\n        // }\n\n        // --- get capabilities --\n        const data = await sendRequest('getRouterRtpCapabilities', {});\n        console.log('getRouterRtpCapabilities:', data);\n        await loadDevice(data);\n        // }\n\n        // --- prepare transport ---\n        console.log('--- createConsumerTransport --');\n        const params = await sendRequest('createConsumerTransport', {});\n        console.log('transport params:', params);\n        consumerTransport.current = device.current.createRecvTransport(params);\n        console.log('createConsumerTransport:', consumerTransport);\n\n        // --- NG ---\n        //sendRequest('connectConsumerTransport', { dtlsParameters: dtlsParameters })\n        //  .then(callback)\n        //  .catch(errback);\n\n        // --- try --- not well\n        //sendRequest('connectConsumerTransport', { dtlsParameters: params.dtlsParameters })\n        //  .then(() => console.log('connectConsumerTransport OK'))\n        //  .catch(err => console.error('connectConsumerTransport ERROR:', err));\n\n        // --- join & start publish --\n        consumerTransport.current.on(\n            'connect',\n            async ({ dtlsParameters }: any, callback: any, errback: any) => {\n                console.log('--consumer trasnport connect');\n                sendRequest('connectConsumerTransport', {\n                    dtlsParameters: dtlsParameters,\n                })\n                    .then(callback)\n                    .catch(errback);\n\n                //consumer = await consumeAndResume(consumerTransport);\n            }\n        );\n\n        consumerTransport.current.on('connectionstatechange', (state: any) => {\n            switch (state) {\n                case 'connecting':\n                    console.log('subscribing...');\n                    break;\n\n                case 'connected':\n                    console.log('subscribed');\n                    setIsSubscribed(true);\n                    break;\n\n                case 'failed':\n                    console.log('failed');\n                    consumerTransport.current.close();\n                    break;\n\n                default:\n                    break;\n            }\n        });\n\n        videoConsumer.current = await consumeAndResume(\n            consumerTransport.current,\n            'video'\n        );\n        audioConsumer.current = await consumeAndResume(\n            consumerTransport.current,\n            'audio'\n        );\n    }\n\n    async function consumeAndResume(transport: any, kind: any) {\n        const consumer = await consume(transport, kind);\n        if (consumer) {\n            console.log('-- track exist, consumer ready. kind=' + kind);\n\n            if (kind === 'video') {\n                console.log('-- resume kind=' + kind);\n                sendRequest('resume', { kind: kind })\n                    .then(() => {\n                        console.log('resume OK');\n                        return consumer;\n                    })\n                    .catch((err) => {\n                        console.error('resume ERROR:', err);\n                        return consumer;\n                    });\n            } else {\n                console.log('-- do not resume kind=' + kind);\n            }\n        } else {\n            console.log('-- no consumer yet. kind=' + kind);\n            return null;\n        }\n    }\n\n    function handleDisconnect() {\n        if (videoConsumer.current) {\n            videoConsumer.current.close();\n            videoConsumer.current = null;\n        }\n        if (audioConsumer.current) {\n            audioConsumer.current.close();\n            audioConsumer.current = null;\n        }\n        if (consumerTransport.current) {\n            consumerTransport.current.close();\n            consumerTransport.current = null;\n        }\n\n        removeAllRemoteVideo();\n\n        disconnectSocket();\n        setIsSubscribed(false);\n    }\n\n    async function loadDevice(routerRtpCapabilities: any) {\n        try {\n            device.current = new Device();\n        } catch (error) {\n            if (error.name === 'UnsupportedError') {\n                console.error('browser not supported');\n            }\n        }\n        await device.current.load({ routerRtpCapabilities });\n    }\n\n    async function consume(transport: any, trackKind: any) {\n        console.log('--start of consume --kind=' + trackKind);\n        const { rtpCapabilities } = device.current;\n        //const data = await socket.request('consume', { rtpCapabilities });\n        const data = await sendRequest('consume', {\n            rtpCapabilities: rtpCapabilities,\n            kind: trackKind,\n        }).catch((err) => {\n            console.error('consume ERROR:', err);\n        });\n        const { producerId, id, kind, rtpParameters }: any = data;\n\n        if (producerId) {\n            let codecOptions = {};\n            const consumer = await transport.consume({\n                id,\n                producerId,\n                kind,\n                rtpParameters,\n                codecOptions,\n            });\n            //const stream = new MediaStream();\n            //stream.addTrack(consumer.track);\n\n            addRemoteTrack(clientId.current, consumer.track);\n\n            console.log('--end of consume');\n            //return stream;\n\n            return consumer;\n        } else {\n            console.warn('--- remote producer NOT READY');\n\n            return null;\n        }\n    }\n\n    function sendRequest(type: any, data: any) {\n        return new Promise((resolve: any, reject: any) => {\n            socketRef.current.emit(type, data, (err: any, response: any) => {\n                if (!err) {\n                    // Success response, so pass the mediasoup response to the local Room.\n                    resolve(response);\n                } else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    function disconnectSocket() {\n        if (socketRef.current) {\n            socketRef.current.close();\n            socketRef.current = null;\n            clientId.current = null;\n            console.log('socket.io closed..');\n        }\n    }\n\n    const connectSocket: any = () => {\n        if (socketRef.current == null) {\n            const io: any = socketIOClient(\n                config.SERVER_ENDPOINT + '/video-broadcast'\n            );\n            socketRef.current = io;\n        }\n\n        return new Promise((resolve: any, reject: any) => {\n            const socket = socketRef.current;\n            socket.on('connect', function (evt: any) {\n                console.log('socket.io connected()');\n            });\n            socket.on('error', function (err: any) {\n                console.error('socket.io ERROR:', err);\n                reject(err);\n            });\n            socket.on('message', function (message: any) {\n                console.log('socket.io message:', message);\n                if (message.type === 'welcome') {\n                    if (socket.id !== message.id) {\n                        console.warn(\n                            'WARN: something wrong with clientID',\n                            socket.io,\n                            message.id\n                        );\n                    }\n\n                    clientId.current = message.id;\n                    console.log(\n                        'connected to server. clientId=' + clientId.current\n                    );\n                    resolve();\n                } else {\n                    console.error('UNKNOWN message from server:', message);\n                }\n            });\n            socket.on('newProducer', async function (message: any) {\n                console.log('socket.io newProducer:', message);\n                if (consumerTransport.current) {\n                    // start consume\n                    if (message.kind === 'video') {\n                        videoConsumer.current = await consumeAndResume(\n                            consumerTransport.current,\n                            message.kind\n                        );\n                    } else if (message.kind === 'audio') {\n                        audioConsumer.current = await consumeAndResume(\n                            consumerTransport.current,\n                            message.kind\n                        );\n                    }\n                }\n            });\n\n            socket.on('producerClosed', function (message: any) {\n                console.log('socket.io producerClosed:', message);\n                const localId = message.localId;\n                const remoteId = message.remoteId;\n                const kind = message.kind;\n                console.log(\n                    '--try removeConsumer remoteId=' +\n                        remoteId +\n                        ', localId=' +\n                        localId +\n                        ', kind=' +\n                        kind\n                );\n                if (kind === 'video') {\n                    if (videoConsumer.current) {\n                        videoConsumer.current.close();\n                        videoConsumer.current = null;\n                    }\n                } else if (kind === 'audio') {\n                    if (audioConsumer.current) {\n                        audioConsumer.current.close();\n                        audioConsumer.current = null;\n                    }\n                }\n\n                if (remoteId) {\n                    removeRemoteVideo(remoteId);\n                } else {\n                    removeAllRemoteVideo();\n                }\n            });\n        });\n    };\n\n    function removeRemoteVideo(id: any) {\n        console.log(' ---- removeRemoteVideo() id=' + id);\n    }\n\n    function removeAllRemoteVideo() {\n        // remoteVideo.current = null;\n        if (remoteVideo.current) {\n            remoteVideo.current.pause();\n            remoteVideo.current.srcObject = null;\n        }\n    }\n\n    return (\n        <div>\n            <button disabled={isSubscribed} onClick={handleSubscribe}>\n                Subscribe\n            </button>\n            <button disabled={!isSubscribed} onClick={handleDisconnect}>\n                Disconnect\n            </button>\n\n            <div>\n                remote video\n                <br />\n                <div>\n                    <video\n                        ref={remoteVideo}\n                        autoPlay\n                        style={{\n                            width: '240px',\n                            height: '180px',\n                            border: '1px solid black',\n                        }}\n                    ></video>\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default Subscribe;\n","/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-broadcast/index.tsx",["69","70"],"/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-conference/room.tsx",["71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86"],"import React, { Suspense, lazy } from 'react';\nimport { Device } from 'mediasoup-client';\nimport { io as socketIOClient } from 'socket.io-client';\nimport { config } from '../../app.config';\n\nconst MODE_STREAM = 'stream';\nconst MODE_SHARE_SCREEN = 'share_screen';\n\nconst CreateRemoteVideos = (props: any) => {\n    const remoteVideo: any = React.useRef();\n    React.useEffect(() => {\n        // if (remoteVideo.current.srcObject) {\n        //     remoteVideo.current.srcObject.addTrack(props.track);\n        //         return;\n        //     }\n        console.log('CreateRemoteVideos');\n        console.log(props);\n        props\n            .playVideo(remoteVideo.current, props.peer.stream)\n            ?.then(() => {\n                remoteVideo.current.volume = 1;\n                console.log('remoteVideo.current');\n                console.log(remoteVideo.current);\n            })\n            .catch((err: any) => {\n                console.error('media ERROR:', err);\n            });\n    }, []);\n    return (\n        <video\n            ref={remoteVideo}\n            controls\n            autoPlay\n            style={{\n                width: '240px',\n                height: '180px',\n                border: '1px solid black',\n            }}\n        ></video>\n    );\n};\nexport const MemoizedCreateRemoteVideos = React.memo(CreateRemoteVideos);\n\nfunction MeetRoom(props: any) {\n    const localScreen: any = React.useRef();\n    const localStreamScreen: any = React.useRef();\n\n    const localVideo: any = React.useRef();\n    const localStream: any = React.useRef();\n    const clientId: any = React.useRef();\n    const device: any = React.useRef();\n    const producerTransport: any = React.useRef();\n    const videoProducer: any = React.useRef({});\n    const audioProducer: any = React.useRef({});\n    const consumerTransport: any = React.useRef();\n    const videoConsumers: any = React.useRef({});\n    const audioConsumers: any = React.useRef({});\n    const consumersStream: any = React.useRef({});\n    const socketRef: any = React.useRef();\n\n    const [useVideo, setUseVideo] = React.useState(true);\n    const [useAudio, setUseAudio] = React.useState(true);\n    const [isStartMedia, setIsStartMedia] = React.useState(false);\n    const [isConnected, setIsConnected] = React.useState(false);\n    const [remoteVideos, setRemoteVideos]: any = React.useState({});\n    const [isShareScreen, setIsShareScreen] = React.useState(false);\n\n    // ============ UI button ==========\n\n    const handleStartScreenShare = () => {\n        if (localStreamScreen.current) {\n            console.warn('WARN: local media ALREADY started');\n            return;\n        }\n\n        const mediaDevices: any = navigator.mediaDevices;\n        mediaDevices\n            .getDisplayMedia({ audio: useAudio, video: useVideo })\n            .then((stream: any) => {\n                localStreamScreen.current = stream;\n\n                playVideo(localScreen.current, localStreamScreen.current);\n                handleConnectScreenShare();\n                setIsShareScreen(true);\n                const screenTrack = stream.getTracks()[0];\n                screenTrack.onended = function () {\n                    handleDisconnectScreenShare();\n                };\n            })\n            .catch((err: any) => {\n                console.error('media ERROR:', err);\n            });\n    };\n\n    async function handleConnectScreenShare() {\n        if (!localStreamScreen.current) {\n            console.warn('WARN: local media NOT READY');\n            return;\n        }\n\n        // // --- connect socket.io ---\n        // await connectSocket().catch((err: any) => {\n        //     console.error(err);\n        //     return;\n        // });\n\n        // console.log('connected');\n\n        // --- get capabilities --\n        const data = await sendRequest('getRouterRtpCapabilities', {});\n        console.log('getRouterRtpCapabilities:', data);\n        await loadDevice(data);\n\n        // --- get transport info ---\n        console.log('--- createProducerTransport --');\n        const params = await sendRequest('createProducerTransport', {\n            mode: MODE_SHARE_SCREEN,\n        });\n        console.log('transport params:', params);\n        producerTransport.current = device.current.createSendTransport(params);\n        console.log('createSendTransport:', producerTransport.current);\n\n        // --- join & start publish --\n        producerTransport.current.on(\n            'connect',\n            async ({ dtlsParameters }: any, callback: any, errback: any) => {\n                console.log('--trasnport connect');\n                sendRequest('connectProducerTransport', {\n                    dtlsParameters: dtlsParameters,\n                })\n                    .then(callback)\n                    .catch(errback);\n            }\n        );\n\n        producerTransport.current.on(\n            'produce',\n            async (\n                { kind, rtpParameters }: any,\n                callback: any,\n                errback: any\n            ) => {\n                console.log('--trasnport produce');\n                try {\n                    const { id }: any = await sendRequest('produce', {\n                        transportId: producerTransport.current.id,\n                        kind,\n                        rtpParameters,\n                        mode: MODE_SHARE_SCREEN,\n                    });\n                    callback({ id });\n                    console.log('--produce requested, then subscribe ---');\n                    subscribe();\n                } catch (err) {\n                    errback(err);\n                }\n            }\n        );\n\n        producerTransport.current.on('connectionstatechange', (state: any) => {\n            switch (state) {\n                case 'connecting':\n                    console.log('publishing...');\n                    break;\n\n                case 'connected':\n                    console.log('published');\n                    //  setIsConnected(true);\n                    break;\n\n                case 'failed':\n                    console.log('failed');\n                    producerTransport.current.close();\n                    break;\n\n                default:\n                    break;\n            }\n        });\n\n        if (useVideo) {\n            const videoTrack = localStreamScreen.current.getVideoTracks()[0];\n            if (videoTrack) {\n                const trackParams = { track: videoTrack };\n                videoProducer.current[\n                    MODE_SHARE_SCREEN\n                ] = await producerTransport.current.produce(trackParams);\n            }\n        }\n        if (useAudio) {\n            const audioTrack = localStreamScreen.current.getAudioTracks()[0];\n            if (audioTrack) {\n                const trackParams = { track: audioTrack };\n                audioProducer.current[\n                    MODE_SHARE_SCREEN\n                ] = await producerTransport.current.produce(trackParams);\n            }\n        }\n    }\n\n    function handleStopScreenShare() {\n        if (localStreamScreen.current) {\n            pauseVideo(localScreen.current);\n            stopLocalStream(localStreamScreen.current);\n            localStreamScreen.current = null;\n            setIsShareScreen(false);\n        }\n    }\n    async function handleDisconnectScreenShare() {\n        handleStopScreenShare();\n        {\n            const producer = videoProducer.current[MODE_SHARE_SCREEN];\n            producer?.close();\n            delete videoProducer.current[MODE_SHARE_SCREEN];\n        }\n        {\n            const producer = audioProducer.current[MODE_SHARE_SCREEN];\n            producer?.close();\n            delete audioProducer.current[MODE_SHARE_SCREEN];\n        }\n\n        await sendRequest('producerStopShareScreen', {});\n    }\n\n    const handleUseVideo = (e: any) => {\n        setUseVideo(!useVideo);\n    };\n    const handleUseAudio = (e: any) => {\n        setUseAudio(!useAudio);\n    };\n\n    const handleStartMedia = () => {\n        if (localStream.current) {\n            console.warn('WARN: local media ALREADY started');\n            return;\n        }\n\n        navigator.mediaDevices\n            .getUserMedia({ audio: useAudio, video: useVideo })\n            .then((stream: any) => {\n                localStream.current = stream;\n                playVideo(localVideo.current, localStream.current);\n                setIsStartMedia(true);\n            })\n            .catch((err: any) => {\n                console.error('media ERROR:', err);\n            });\n    };\n\n    function handleStopMedia() {\n        if (localStream.current) {\n            pauseVideo(localVideo.current);\n            stopLocalStream(localStream.current);\n            localStream.current = null;\n            setIsStartMedia(false);\n        }\n    }\n\n    function handleDisconnect() {\n        handleStopMedia();\n        handleStopScreenShare();\n        // if (videoProducer.current) {\n        //     videoProducer.current.close(); // localStream will stop\n        //     videoProducer.current = null;\n        // }\n        {\n            for (const mode in videoProducer.current) {\n                const producer = videoProducer.current[mode];\n                producer?.close();\n                delete videoProducer.current[mode];\n            }\n        }\n        {\n            for (const mode in audioProducer.current) {\n                const producer = audioProducer.current[mode];\n                producer?.close();\n                delete audioProducer.current[mode];\n            }\n        }\n        // if (audioProducer.current) {\n        //     audioProducer.current.close(); // localStream will stop\n        //     audioProducer.current = null;\n        // }\n        if (producerTransport.current) {\n            producerTransport.current.close(); // localStream will stop\n            producerTransport.current = null;\n        }\n\n        for (const key in videoConsumers.current) {\n            for (const key2 in videoConsumers.current[key]) {\n                const consumer = videoConsumers.current[key][key2];\n                consumer.close();\n                delete videoConsumers.current[key][key2];\n            }\n        }\n        for (const key in audioConsumers.current) {\n            for (const key2 in audioConsumers.current[key]) {\n                const consumer = audioConsumers.current[key][key2];\n                consumer.close();\n                delete audioConsumers.current[key][key2];\n            }\n        }\n\n        if (consumersStream.current) {\n            consumersStream.current = {};\n        }\n\n        if (consumerTransport.current) {\n            consumerTransport.current.close();\n            consumerTransport.current = null;\n        }\n\n        removeAllRemoteVideo();\n\n        disconnectSocket();\n        setIsConnected(false);\n    }\n\n    function playVideo(element: any, stream: any) {\n        if (element.srcObject) {\n            console.warn('element ALREADY playing, so ignore');\n            return;\n        }\n        element.srcObject = stream;\n        element.volume = 0;\n        return element.play();\n    }\n\n    function pauseVideo(element: any) {\n        element.pause();\n        element.srcObject = null;\n    }\n\n    function stopLocalStream(stream: any) {\n        let tracks = stream.getTracks();\n        if (!tracks) {\n            console.warn('NO tracks');\n            return;\n        }\n\n        tracks.forEach((track: any) => track.stop());\n    }\n\n    function addRemoteTrack(id: any, track: any, mode: string) {\n        // let video: any = findRemoteVideo(id);\n        // if (!video) {\n        //     video = addRemoteVideo(id);\n        //     video.controls = '1';\n        // }\n\n        // if (video.srcObject) {\n        //     video.srcObject.addTrack(track);\n        //     return;\n        // }\n\n        if (id === clientId.current) {\n            return false;\n        }\n\n        console.log('addremotetrack');\n        console.log(track);\n\n        if (consumersStream.current[id] == undefined) {\n            consumersStream.current[id] = {};\n        }\n\n        if (consumersStream.current[id][mode] == undefined) {\n            const newStream = new MediaStream();\n            newStream.addTrack(track);\n            consumersStream.current[id][mode] = {\n                stream: newStream,\n                socket_id: id,\n            };\n        } else {\n            //add audiotrack\n            consumersStream.current[id][mode].stream.addTrack(track);\n        }\n\n        setRemoteVideos((peers: any) => {\n            const newPeers: any = peers;\n\n            return { ...consumersStream.current };\n        });\n\n        // setRemoteVideos((peers: any) => {\n        //     const newPeers: any = peers;\n        //     if (newPeers[id] == undefined) {\n        //         newPeers[id] = {};\n        //     }\n        //     newPeers[id][mode] = {\n        //         stream: newStream,\n        //         socket_id: id,\n        //     };\n        //     return { ...peers, ...newPeers };\n        // });\n        // setShouldLoadConsumerShareScreen\n\n        // playVideo(video, newStream)\n        //     .then(() => {\n        //         video.volume = 1.0;\n        //     })\n        //     .catch((err: any) => {\n        //         console.error('media ERROR:', err);\n        //     });\n    }\n\n    function addRemoteVideo(id: any) {\n        let existElement = findRemoteVideo(id);\n        if (existElement) {\n            console.warn('remoteVideo element ALREADY exist for id=' + id);\n            return existElement;\n        }\n\n        let element = document.createElement('video');\n        return element;\n    }\n\n    function findRemoteVideo(id: any) {\n        let element = remoteVideos.current[id];\n        return element;\n    }\n\n    // function removeRemoteVideoByMode(id: any, mode: string) {\n    //     console.log(' ---- removeRemoteVideo() id=' + id);\n    //     delete consumersStream.current[id][mode];\n    //     setRemoteVideos((peers: any) => {\n    //         const newPeers: any = peers;\n    //         delete newPeers[id][mode];\n\n    //         return { ...peers, ...newPeers };\n    //     });\n    // }\n\n    function removeRemoteVideo(id: any, mode: string) {\n        console.log(' ---- removeRemoteVideo() id=' + id);\n        if (mode == MODE_STREAM) {\n            delete consumersStream.current[id];\n        } else {\n            delete consumersStream.current[id][mode];\n        }\n\n        setRemoteVideos((peers: any) => {\n            const newPeers: any = peers;\n            delete newPeers[id];\n\n            return { ...consumersStream.current };\n        });\n        // if (element) {\n        //     element.pause();\n        //     element.srcObject = null;\n        //     remoteContainer.removeChild(element);\n        // } else {\n        //     console.log('child element NOT FOUND');\n        // }\n    }\n\n    function removeAllRemoteVideo() {\n        console.log(' ---- removeAllRemoteVideo() id');\n        consumersStream.current = {};\n        setRemoteVideos((peers: any) => {\n            const newPeers = {};\n\n            return { ...newPeers };\n        });\n        // while (remoteContainer.firstChild) {\n        //     remoteContainer.firstChild.pause();\n        //     remoteContainer.firstChild.srcObject = null;\n        //     remoteContainer.removeChild(remoteContainer.firstChild);\n        // }\n    }\n\n    async function consumeAdd(\n        transport: any,\n        remoteSocketId: any,\n        prdId: any,\n        trackKind: any,\n        mode: any = MODE_STREAM\n    ) {\n        console.log('--start of consumeAdd -- kind=%s', trackKind);\n        const { rtpCapabilities } = device.current;\n        //const data = await socket.request('consume', { rtpCapabilities });\n        const data = await sendRequest('consumeAdd', {\n            rtpCapabilities: rtpCapabilities,\n            remoteId: remoteSocketId,\n            kind: trackKind,\n            mode: mode,\n        }).catch((err) => {\n            console.error('consumeAdd ERROR:', err);\n        });\n        const { producerId, id, kind, rtpParameters }: any = data;\n        if (prdId && prdId !== producerId) {\n            console.warn('producerID NOT MATCH');\n        }\n\n        let codecOptions = {};\n        const consumer = await transport.consume({\n            id,\n            producerId,\n            kind,\n            rtpParameters,\n            codecOptions,\n            mode,\n        });\n        //const stream = new MediaStream();\n        //stream.addTrack(consumer.track);\n\n        addConsumer(remoteSocketId, consumer, kind, mode);\n        consumer.remoteId = remoteSocketId;\n        consumer.on('transportclose', () => {\n            console.log(\n                '--consumer transport closed. remoteId=' + consumer.remoteId\n            );\n            //consumer.close();\n            //removeConsumer(remoteId);\n            //removeRemoteVideo(consumer.remoteId);\n        });\n        consumer.on('producerclose', () => {\n            console.log(\n                '--consumer producer closed. remoteId=' + consumer.remoteId\n            );\n            consumer.close();\n            removeConsumer(consumer.remoteId, kind, mode);\n            removeRemoteVideo(consumer.remoteId, mode);\n        });\n        consumer.on('trackended', () => {\n            console.log('--consumer trackended. remoteId=' + consumer.remoteId);\n            //consumer.close();\n            //removeConsumer(remoteId);\n            //removeRemoteVideo(consumer.remoteId);\n        });\n\n        console.log('--end of consumeAdd');\n        //return stream;\n\n        if (kind === 'video') {\n            console.log('--try resumeAdd --');\n            sendRequest('resumeAdd', {\n                remoteId: remoteSocketId,\n                kind: kind,\n                mode,\n            })\n                .then(() => {\n                    console.log('resumeAdd OK');\n                })\n                .catch((err) => {\n                    console.error('resumeAdd ERROR:', err);\n                });\n        }\n        return new Promise((resolve: any, reject: any) => {\n            addRemoteTrack(remoteSocketId, consumer.track, mode);\n            resolve();\n        });\n    }\n\n    async function handleConnect() {\n        if (!localStream.current) {\n            console.warn('WARN: local media NOT READY');\n            return;\n        }\n\n        // --- connect socket.io ---\n        await connectSocket().catch((err: any) => {\n            console.error(err);\n            return;\n        });\n\n        console.log('connected');\n\n        // --- get capabilities --\n        const data = await sendRequest('getRouterRtpCapabilities', {});\n        console.log('getRouterRtpCapabilities:', data);\n        await loadDevice(data);\n\n        // --- get transport info ---\n        console.log('--- createProducerTransport --');\n        const params = await sendRequest('createProducerTransport', {\n            mode: MODE_STREAM,\n        });\n        console.log('transport params:', params);\n        producerTransport.current = device.current.createSendTransport(params);\n        console.log('createSendTransport:', producerTransport.current);\n\n        // --- join & start publish --\n        producerTransport.current.on(\n            'connect',\n            async ({ dtlsParameters }: any, callback: any, errback: any) => {\n                console.log('--trasnport connect');\n                sendRequest('connectProducerTransport', {\n                    dtlsParameters: dtlsParameters,\n                })\n                    .then(callback)\n                    .catch(errback);\n            }\n        );\n\n        producerTransport.current.on(\n            'produce',\n            async (\n                { kind, rtpParameters }: any,\n                callback: any,\n                errback: any\n            ) => {\n                console.log('--trasnport produce');\n                try {\n                    const { id }: any = await sendRequest('produce', {\n                        transportId: producerTransport.current.id,\n                        kind,\n                        rtpParameters,\n                        mode: MODE_STREAM,\n                    });\n                    callback({ id });\n                    console.log('--produce requested, then subscribe ---');\n                    subscribe();\n                } catch (err) {\n                    errback(err);\n                }\n            }\n        );\n\n        producerTransport.current.on('connectionstatechange', (state: any) => {\n            switch (state) {\n                case 'connecting':\n                    console.log('publishing...');\n                    break;\n\n                case 'connected':\n                    console.log('published');\n                    setIsConnected(true);\n                    break;\n\n                case 'failed':\n                    console.log('failed');\n                    producerTransport.current.close();\n                    break;\n\n                default:\n                    break;\n            }\n        });\n\n        if (useVideo) {\n            const videoTrack = localStream.current.getVideoTracks()[0];\n            if (videoTrack) {\n                const trackParams = { track: videoTrack };\n                videoProducer.current[\n                    MODE_STREAM\n                ] = await producerTransport.current.produce(trackParams);\n            }\n        }\n        if (useAudio) {\n            const audioTrack = localStream.current.getAudioTracks()[0];\n            if (audioTrack) {\n                const trackParams = { track: audioTrack };\n                audioProducer.current[\n                    MODE_STREAM\n                ] = await producerTransport.current.produce(trackParams);\n            }\n        }\n    }\n\n    async function subscribe() {\n        // console.log(socketRef.current);\n        if (!socketRef.current) {\n            await connectSocket().catch((err: any) => {\n                console.error(err);\n                return;\n            });\n        }\n\n        // --- get capabilities --\n        const data = await sendRequest('getRouterRtpCapabilities', {});\n        console.log('getRouterRtpCapabilities:', data);\n        await loadDevice(data);\n        //  }\n\n        // --- prepare transport ---\n        console.log('--- createConsumerTransport --');\n        if (!consumerTransport.current) {\n            const params = await sendRequest('createConsumerTransport', {});\n            console.log('transport params:', params);\n            consumerTransport.current = device.current.createRecvTransport(\n                params\n            );\n            console.log('createConsumerTransport:', consumerTransport.current);\n\n            // --- join & start publish --\n            consumerTransport.current.on(\n                'connect',\n                async (\n                    { dtlsParameters }: any,\n                    callback: any,\n                    errback: any\n                ) => {\n                    console.log('--consumer trasnport connect');\n                    sendRequest('connectConsumerTransport', {\n                        dtlsParameters: dtlsParameters,\n                    })\n                        .then(callback)\n                        .catch(errback);\n                }\n            );\n\n            consumerTransport.current.on(\n                'connectionstatechange',\n                (state: any) => {\n                    switch (state) {\n                        case 'connecting':\n                            console.log('subscribing...');\n                            break;\n\n                        case 'connected':\n                            console.log('subscribed');\n                            //consumeCurrentProducers(clientId);\n                            break;\n\n                        case 'failed':\n                            console.log('failed');\n                            producerTransport.current.close();\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            );\n\n            consumeCurrentProducers(clientId.current);\n        }\n    }\n\n    async function loadDevice(routerRtpCapabilities: any) {\n        try {\n            device.current = new Device();\n        } catch (error) {\n            if (error.name === 'UnsupportedError') {\n                console.error('browser not supported');\n            }\n        }\n        await device.current.load({ routerRtpCapabilities });\n    }\n\n    function sendRequest(type: any, data: any) {\n        return new Promise((resolve: any, reject: any) => {\n            socketRef.current.emit(type, data, (err: any, response: any) => {\n                if (!err) {\n                    // Success response, so pass the mediasoup response to the local Room.\n                    resolve(response);\n                } else {\n                    reject(err);\n                }\n            });\n        });\n    }\n\n    async function consumeCurrentProducers(clientId: any) {\n        console.log('-- try consuleAll() --');\n        const remoteInfo: any = await sendRequest('getCurrentProducers', {\n            localId: clientId.current,\n        }).catch((err) => {\n            console.error('getCurrentProducers ERROR:', err);\n            return;\n        });\n        //console.log('remoteInfo.producerIds:', remoteInfo.producerIds);\n        console.log('remoteInfo.remoteVideoIds:', remoteInfo.remoteVideoIds);\n        console.log('remoteInfo.remoteAudioIds:', remoteInfo.remoteAudioIds);\n        consumeAll(\n            consumerTransport.current,\n            remoteInfo.remoteVideoIds,\n            remoteInfo.remoteAudioIds\n        );\n    }\n\n    function consumeAll(\n        transport: any,\n        remoteVideoIds: any,\n        remotAudioIds: any\n    ) {\n        console.log('----- consumeAll() -----');\n\n        remoteVideoIds.forEach((rId: any) => {\n            consumeAdd(transport, rId, null, 'video', MODE_STREAM).then(\n                (resp: any) => {\n                    consumeAdd(\n                        transport,\n                        rId,\n                        null,\n                        'video',\n                        MODE_SHARE_SCREEN\n                    );\n                }\n            );\n        });\n        let audioIdsCount = 0;\n        remotAudioIds.forEach((rId: any) => {\n            consumeAdd(transport, rId, null, 'audio', MODE_STREAM).then(\n                (resp: any) => {\n                    consumeAdd(\n                        transport,\n                        rId,\n                        null,\n                        'audio',\n                        MODE_SHARE_SCREEN\n                    );\n                }\n            );\n        });\n    }\n\n    function disconnectSocket() {\n        if (socketRef.current) {\n            socketRef.current.close();\n            socketRef.current = null;\n            clientId.current = null;\n            console.log('socket.io closed..');\n        }\n    }\n\n    function removeConsumer(id: any, kind: any, mode: string) {\n        if (mode == undefined) {\n            return false;\n        }\n        if (kind === 'video') {\n            if (mode == MODE_STREAM) {\n                delete videoConsumers.current[id];\n            } else {\n                delete videoConsumers.current[id][mode];\n            }\n\n            console.log(\n                'videoConsumers count=' +\n                    Object.keys(videoConsumers.current).length\n            );\n        } else if (kind === 'audio') {\n            if (mode == MODE_STREAM) {\n                delete audioConsumers.current[id];\n            } else {\n                delete audioConsumers.current[id][mode];\n            }\n\n            console.log(\n                'audioConsumers count=' +\n                    Object.keys(audioConsumers.current).length\n            );\n        } else {\n            console.warn('UNKNOWN consumer kind=' + kind);\n        }\n    }\n\n    // function getConsumer(id: any, kind: any) {\n    //     if (kind === 'video') {\n    //         return videoConsumers.current[id];\n    //     } else if (kind === 'audio') {\n    //         return audioConsumers.current[id];\n    //     } else {\n    //         console.warn('UNKNOWN consumer kind=' + kind);\n    //     }\n    // }\n\n    function addConsumer(id: any, consumer: any, kind: any, mode: any) {\n        if (id === clientId.current) {\n            return false;\n        }\n        if (kind === 'video') {\n            if (videoConsumers.current[id] == undefined) {\n                videoConsumers.current[id] = {};\n            }\n            videoConsumers.current[id][mode] = consumer;\n            console.log(\n                'videoConsumers count=' +\n                    Object.keys(videoConsumers.current).length\n            );\n        } else if (kind === 'audio') {\n            if (audioConsumers.current[id] == undefined) {\n                audioConsumers.current[id] = {};\n            }\n            audioConsumers.current[id][mode] = consumer;\n\n            console.log(\n                'audioConsumers count=' +\n                    Object.keys(audioConsumers.current).length\n            );\n        } else {\n            console.warn('UNKNOWN consumer kind=' + kind);\n        }\n    }\n\n    const connectSocket: any = () => {\n        if (socketRef.current == null) {\n            const io: any = socketIOClient(\n                config.SERVER_ENDPOINT + '/video-conference'\n            );\n            socketRef.current = io;\n        }\n\n        return new Promise((resolve: any, reject: any) => {\n            const socket = socketRef.current;\n\n            socket.on('connect', function (evt: any) {\n                console.log('socket.io connected()');\n            });\n            socket.on('error', function (err: any) {\n                console.error('socket.io ERROR:', err);\n                reject(err);\n            });\n            socket.on('message', function (message: any) {\n                console.log('socket.io message:', message);\n                if (message.type === 'welcome') {\n                    if (socket.id !== message.id) {\n                        console.warn(\n                            'WARN: something wrong with clientID',\n                            socket.io,\n                            message.id\n                        );\n                    }\n\n                    clientId.current = message.id;\n                    console.log(\n                        'connected to server. clientId=' + clientId.current\n                    );\n                    resolve();\n                } else {\n                    console.error('UNKNOWN message from server:', message);\n                }\n            });\n            socket.on('newProducer', function (message: any) {\n                console.log('socket.io newProducer:', message);\n                const remoteId = message.socketId;\n                const prdId = message.producerId;\n                const kind = message.kind;\n                const mode = message.mode;\n\n                if (kind === 'video') {\n                    console.log(\n                        '--try consumeAdd remoteId=' +\n                            remoteId +\n                            ', prdId=' +\n                            prdId +\n                            ', kind=' +\n                            kind\n                    );\n                    consumeAdd(\n                        consumerTransport.current,\n                        remoteId,\n                        prdId,\n                        kind,\n                        mode\n                    );\n                } else if (kind === 'audio') {\n                    //console.warn('-- audio NOT SUPPORTED YET. skip remoteId=' + remoteId + ', prdId=' + prdId + ', kind=' + kind);\n                    console.log(\n                        '--try consumeAdd remoteId=' +\n                            remoteId +\n                            ', prdId=' +\n                            prdId +\n                            ', kind=' +\n                            kind\n                    );\n                    consumeAdd(\n                        consumerTransport.current,\n                        remoteId,\n                        prdId,\n                        kind,\n                        mode\n                    );\n                }\n            });\n\n            socket.on('producerClosed', function (message: any) {\n                console.log('socket.io producerClosed:', message);\n                const localId = message.localId;\n                const remoteId = message.remoteId;\n                const kind = message.kind;\n                const mode = message.mode;\n                console.log(\n                    '--try removeConsumer remoteId=%s, localId=%s, track=%s',\n                    remoteId,\n                    localId,\n                    kind\n                );\n                removeConsumer(remoteId, kind, mode);\n                removeRemoteVideo(remoteId, mode);\n            });\n            // socket.on('shareScreenClosed', function (payload: any) {\n            //     console.log('socket.io shareScreenClosed:', payload);\n            //     const callerID = payload.callerID;\n\n            //     removeConsumer(callerID, 'video', MODE_SHARE_SCREEN);\n            //     removeConsumer(callerID, 'audio', MODE_SHARE_SCREEN);\n            //     removeRemoteVideoByMode(callerID, MODE_SHARE_SCREEN);\n            // });\n        });\n    };\n\n    return (\n        <div>\n            <div>\n                <input\n                    disabled={isStartMedia}\n                    onChange={handleUseVideo}\n                    type='checkbox'\n                    checked={useVideo}\n                ></input>\n                <label>video</label>\n            </div>\n            <div>\n                <input\n                    disabled={isStartMedia}\n                    onChange={handleUseAudio}\n                    type='checkbox'\n                    checked={useAudio}\n                ></input>\n                <label>audio</label>\n            </div>\n\n            {!isStartMedia ? (\n                <button disabled={isStartMedia} onClick={handleStartMedia}>\n                    Start Media\n                </button>\n            ) : (\n                <button\n                    disabled={!isStartMedia || isConnected}\n                    onClick={handleStopMedia}\n                >\n                    Stop Media\n                </button>\n            )}\n            {!isConnected ? (\n                <button\n                    disabled={isConnected || !isStartMedia}\n                    onClick={handleConnect}\n                >\n                    Connect\n                </button>\n            ) : (\n                <button\n                    disabled={!isConnected || !isStartMedia}\n                    onClick={handleDisconnect}\n                >\n                    Disconnect\n                </button>\n            )}\n\n            {isShareScreen ? (\n                <button\n                    disabled={!isStartMedia || !isConnected}\n                    onClick={handleDisconnectScreenShare}\n                >\n                    Stop Screen\n                </button>\n            ) : (\n                <button\n                    disabled={!isStartMedia || !isConnected}\n                    onClick={handleStartScreenShare}\n                >\n                    Start Screen\n                </button>\n            )}\n\n            <div>\n                local video\n                <video\n                    ref={localVideo}\n                    autoPlay\n                    controls\n                    style={{\n                        width: '240px',\n                        height: '180px',\n                        border: '1px solid black',\n                    }}\n                ></video>\n                <video\n                    ref={localScreen}\n                    controls\n                    autoPlay\n                    style={{\n                        width: '240px',\n                        height: '180px',\n                        border: '1px solid black',\n                    }}\n                ></video>\n            </div>\n            <div>remote videos</div>\n            {console.log(remoteVideos)}\n            {Object.keys(remoteVideos).map((key: any, index: number) => {\n                return Object.keys(remoteVideos[key]).map(\n                    (key2: any, index2: number) => {\n                        const peer: any = remoteVideos[key][key2];\n\n                        return (\n                            <MemoizedCreateRemoteVideos\n                                key={peer.socket_id + '__' + key2}\n                                peer={peer}\n                                playVideo={playVideo}\n                            />\n                        );\n                    }\n                );\n            })}\n        </div>\n    );\n}\n\nexport default MeetRoom;\n","/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-broadcast/publish.tsx",["87","88"],"/home/izzud/Desktop/app/webrtc_mediasoup/src/PAGE/video-conference/index.tsx",["89","90","91"],"import Layout from '../../CONTAINER/layout';\n\nimport MeetRoom from './room';\nimport { io as socketIOClient } from 'socket.io-client';\nimport { config } from '../../app.config';\n\n// const socketIO: any = socketIOClient(\n//     config.SERVER_ENDPOINT + '/video-conference'\n// );\n\nfunction Home(props: any) {\n    const view = props.match.params.view;\n    return (\n        <Layout>\n            <MeetRoom\n            //  io={socketIO}\n            />\n        </Layout>\n    );\n}\n\nexport default Home;\n",["92","93"],{"ruleId":"94","replacedBy":"95"},{"ruleId":"96","replacedBy":"97"},{"ruleId":"98","severity":1,"message":"99","line":2,"column":8,"nodeType":"100","messageId":"101","endLine":2,"endColumn":12},{"ruleId":"98","severity":1,"message":"102","line":3,"column":25,"nodeType":"100","messageId":"101","endLine":3,"endColumn":33},{"ruleId":"98","severity":1,"message":"103","line":4,"column":16,"nodeType":"100","messageId":"101","endLine":4,"endColumn":30},{"ruleId":"94","replacedBy":"104"},{"ruleId":"96","replacedBy":"105"},{"ruleId":"106","severity":1,"message":"107","line":1,"column":17,"nodeType":"100","messageId":"101","endLine":1,"endColumn":23},{"ruleId":"106","severity":1,"message":"108","line":3,"column":10,"nodeType":"100","messageId":"101","endLine":3,"endColumn":29},{"ruleId":"106","severity":1,"message":"109","line":8,"column":15,"nodeType":"100","messageId":"101","endLine":8,"endColumn":30},{"ruleId":"106","severity":1,"message":"110","line":1,"column":17,"nodeType":"100","messageId":"101","endLine":1,"endColumn":25},{"ruleId":"106","severity":1,"message":"111","line":1,"column":27,"nodeType":"100","messageId":"101","endLine":1,"endColumn":31},{"ruleId":"106","severity":1,"message":"112","line":7,"column":11,"nodeType":"100","messageId":"101","endLine":7,"endColumn":27},{"ruleId":"106","severity":1,"message":"113","line":17,"column":12,"nodeType":"100","messageId":"101","endLine":17,"endColumn":23},{"ruleId":"106","severity":1,"message":"114","line":17,"column":25,"nodeType":"100","messageId":"101","endLine":17,"endColumn":39},{"ruleId":"106","severity":1,"message":"115","line":33,"column":14,"nodeType":"100","messageId":"101","endLine":33,"endColumn":24},{"ruleId":"106","severity":1,"message":"103","line":4,"column":16,"nodeType":"100","messageId":"101","endLine":4,"endColumn":30},{"ruleId":"106","severity":1,"message":"116","line":5,"column":10,"nodeType":"100","messageId":"101","endLine":5,"endColumn":16},{"ruleId":"106","severity":1,"message":"110","line":1,"column":17,"nodeType":"100","messageId":"101","endLine":1,"endColumn":25},{"ruleId":"106","severity":1,"message":"111","line":1,"column":27,"nodeType":"100","messageId":"101","endLine":1,"endColumn":31},{"ruleId":"117","severity":1,"message":"118","line":28,"column":8,"nodeType":"119","endLine":28,"endColumn":10,"suggestions":"120"},{"ruleId":"121","severity":1,"message":"122","line":266,"column":9,"nodeType":"123","messageId":"124","endLine":272,"endColumn":10},{"ruleId":"121","severity":1,"message":"122","line":273,"column":9,"nodeType":"123","messageId":"124","endLine":279,"endColumn":10},{"ruleId":"125","severity":1,"message":"126","line":363,"column":41,"nodeType":"127","messageId":"128","endLine":363,"endColumn":43},{"ruleId":"125","severity":1,"message":"126","line":367,"column":47,"nodeType":"127","messageId":"128","endLine":367,"endColumn":49},{"ruleId":"106","severity":1,"message":"129","line":380,"column":19,"nodeType":"100","messageId":"101","endLine":380,"endColumn":32},{"ruleId":"106","severity":1,"message":"130","line":407,"column":14,"nodeType":"100","messageId":"101","endLine":407,"endColumn":28},{"ruleId":"125","severity":1,"message":"126","line":436,"column":18,"nodeType":"127","messageId":"128","endLine":436,"endColumn":20},{"ruleId":"106","severity":1,"message":"131","line":793,"column":13,"nodeType":"100","messageId":"101","endLine":793,"endColumn":26},{"ruleId":"125","severity":1,"message":"126","line":819,"column":18,"nodeType":"127","messageId":"128","endLine":819,"endColumn":20},{"ruleId":"125","severity":1,"message":"126","line":823,"column":22,"nodeType":"127","messageId":"128","endLine":823,"endColumn":24},{"ruleId":"125","severity":1,"message":"126","line":834,"column":22,"nodeType":"127","messageId":"128","endLine":834,"endColumn":24},{"ruleId":"125","severity":1,"message":"126","line":864,"column":44,"nodeType":"127","messageId":"128","endLine":864,"endColumn":46},{"ruleId":"125","severity":1,"message":"126","line":873,"column":44,"nodeType":"127","messageId":"128","endLine":873,"endColumn":46},{"ruleId":"106","severity":1,"message":"110","line":1,"column":17,"nodeType":"100","messageId":"101","endLine":1,"endColumn":25},{"ruleId":"106","severity":1,"message":"111","line":1,"column":27,"nodeType":"100","messageId":"101","endLine":1,"endColumn":31},{"ruleId":"106","severity":1,"message":"103","line":4,"column":16,"nodeType":"100","messageId":"101","endLine":4,"endColumn":30},{"ruleId":"106","severity":1,"message":"116","line":5,"column":10,"nodeType":"100","messageId":"101","endLine":5,"endColumn":16},{"ruleId":"106","severity":1,"message":"132","line":12,"column":11,"nodeType":"100","messageId":"101","endLine":12,"endColumn":15},{"ruleId":"94","replacedBy":"104"},{"ruleId":"96","replacedBy":"105"},"no-native-reassign",["133"],"no-negated-in-lhs",["134"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'Redirect' is defined but never used.","'socketIOClient' is defined but never used.",["133"],["134"],"@typescript-eslint/no-unused-vars","'useRef' is defined but never used.","'isPropertySignature' is defined but never used.","'userSocket' is assigned a value but never used.","'Suspense' is defined but never used.","'lazy' is defined but never used.","'localStream' is assigned a value but never used.","'isConnected' is assigned a value but never used.","'setIsConnected' is assigned a value but never used.","'pauseVideo' is defined but never used.","'config' is defined but never used.","react-hooks/exhaustive-deps","React Hook React.useEffect has a missing dependency: 'props'. Either include it or remove the dependency array.","ArrayExpression",["135"],"no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'newPeers' is assigned a value but never used.","'addRemoteVideo' is defined but never used.","'audioIdsCount' is assigned a value but never used.","'view' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"136","fix":"137"},"Update the dependencies array to be: [props]",{"range":"138","text":"139"},[992,994],"[props]"]